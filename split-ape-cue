#!/usr/bin/env perl

use strict;
use warnings;
use Encode qw(decode encode);
use Getopt::Std;
use Data::Dumper;

sub get_loc_charenc() {
    my $charenc;
    # the simplest way: trailing charmap in LANG/etc:
    foreach my $k (qw(LC_ALL LC_CTYPE LANG)) {
	return $2
	    if defined $ENV{$k} and $ENV{$k} =~ /^([^.]+)\.(.*)$/;
    };
    # nl_langinfo (3)      - query language and locale information,
    # its perl counterpart is implemented as I18N::Langinfo:
    eval {
	require I18N::Langinfo;
	import  I18N::Langinfo;
	$charenc = I18N::Langinfo::langinfo(
	    I18N::Langinfo::CODESET());
    };
    return $charenc if defined $charenc and $charenc ne "";
    # try executing `locale charmap`:
    eval {$charenc = `locale charmap`};
    chomp $charenc if defined $charenc;
    return $charenc if defined $charenc and $charenc ne "";
    # assume utf8 by default:
    return "utf8";
};

# XXX : $loc_charenc is a global variable.
my $loc_charenc = get_loc_charenc();

# Return locale-encoded $x or undef.
sub str_($) {
    return (defined $_[0]) ? encode($loc_charenc, $_[0]) : undef;
};

# Return $x converted to printable (locale-encoded) string.
sub str($) {
    return (defined $_[0]) ? encode($loc_charenc, $_[0]) : "???";
};


sub sum_digits_base_n($$) {
    my ($x, $base) = @_;
    my $s = 0;
    use integer;
    while ($x > 0) {
	$s = $s + ($x % $base);
	$x = $x / $base;
    };
    return $s;
};

# Return total play time of the .ape file in seconds (rounded down).
sub get_ape_playtime($) {
    my ($ape_fname) = @_;
    my $ape_fname_ = encode($loc_charenc, $ape_fname);
    my $ape_time;
    # fork child ffmpeg process:
    my $ffmpeg_pid = open my $ffmpeg_out, "-|";
    die "cannot fork: $!" if not defined $ffmpeg_pid;
    if ($ffmpeg_pid == 0) {
	# child process
	open STDERR, ">&STDOUT"
	    or die "Cannot redirect STDERR to STDOUT: $!";
	exec {"ffmpeg"} ("ffmpeg", "-i", $ape_fname_)
	    or die "Cannot execute ffmpeg: $!";
    } else {
	# parent process
	while (<$ffmpeg_out>) {
	    #  Duration: 00:46:25.43, start: 0.000000, ...
	    if (/^\s*Duration:\s*(\d\d):(\d\d):(\d\d)
	    \.\d+,/ix) {
		$ape_time = ($1 * 60 + $2) * 60 + $3;
	    }
	};
	close $ffmpeg_out;
    };
    die "cannot detect playtime of $ape_fname_\n"
	if not defined $ape_time;
    return $ape_time;
};

sub calculate_discid($$) {
    my ($c, $ape_fname) = @_;
    return if defined $c->{disc}->{discid};
    use integer;
    # XXX: track01 typically starts at 2 sec (150 frames) offset:
    @{$c->{disc}->{track_offsets}} =
	map {150 + $c->{$_}->{index01}->{offs}}
	sort {$a <=> $b} grep {$_ ne "disc"} keys %$c;
    $c->{disc}->{offsum} = 0;
    $c->{disc}->{offsum} += sum_digits_base_n($_ / 75, 10)
	foreach @{$c->{disc}->{track_offsets}};
    no integer;
    # detect total play time of the disc:
    $c->{disc}->{ape_time} = get_ape_playtime($ape_fname);
    # calculate discid "hash" for CDDB server:
    $c->{disc}->{discid} = sprintf "%02x%04x%02x",
	$c->{disc}->{offsum} % 255,
	$c->{disc}->{ape_time},
	$c->{disc}->{tracks};
    printf "WARNING: discid_cue:%s != discid:%s\n",
	    $c->{disc}->{discid_cue}, $c->{disc}->{discid}
	if defined $c->{disc}->{discid_cue} and
	    lc($c->{disc}->{discid_cue}) ne $c->{disc}->{discid};
};

sub double_slashes($) {
    my ($x) = @_;
    return $x if not defined $x;
    $x =~ s!/!//!g;
    return $x;
};

sub halve_slashes($) {
    my ($x) = @_;
    return $x if not defined $x;
    $x =~ s!//!/!g;
    return $x;
};

sub put_together_dtitle($) {
    my ($dinfo) = @_;
    if (defined $dinfo->{_title}) {
	if (defined $dinfo->{_performer}) {
	    $dinfo->{dtitle} = double_slashes($dinfo->{_performer})
		." / ".double_slashes($dinfo->{_title});
	} else {
	    $dinfo->{dtitle} = double_slashes($dinfo->{_title});
	};
    };
};

# Parse contents of the given .cue and .ape files.
# Return hash:
# {disc=>{discid_cue=>, dtitle=>, _performer=>, _title=>, dyear=>,
#    dgenre=>, ttitles=>, tracks=>, maxtrack=>, discid=>...},
#  1=>{type=>, _performer=>, _title=>,
#   [index00=>{...},] - "pre-gap" index if available
#    index01=>{h=>, m=>, s=>, ms_ceil=>, ms_floor=>, offs=>...},
#    ...
#  },
#  2=>{...},
#  ...
# }
sub parse_cue_ape($$) {
    my ($cue_fname, $ape_fname) = @_;
    my $cue_fname_ = encode($loc_charenc, $cue_fname);
    open (my $cue_fd, "<", $cue_fname_)
	or die "cannot open $cue_fname_ - $!\n";
    my $c;
    my $t = "disc";
    while (<$cue_fd>) {
	# XXX assume "utf8" encoding for .cue file data:
	$_ = decode("utf8", $_);
	if (/^\s*title\s+"(.*)"\s*$/i) {
	    my $title = $1;
	    $c->{$t}->{_title} = $title
		if $title !~ /^\s*track\s*\d+\s*$/i;
	} elsif (/^\s*performer\s+"(.*)"\s*$/i) {
	    $c->{$t}->{_performer} = $1;
	} elsif (/^\s*rem\s+date\s+(\d+)\s*$/i) {
	    $c->{$t}->{dyear} = $1;
	} elsif (/^\s*rem\s+genre\s+("(.*)"|([^\r\n]*\S))\s*$/i) {
	    $c->{$t}->{dgenre} = (defined $2) ? $2 : $3;
	} elsif (/^\s*rem\s+comment\s+([^\r\n]*\S)\s*$/i) {
	    $c->{$t}->{comment} = $1;
	} elsif (/^\s*file\s+"(.*)"\s+(wave)\s*$/i) {
	    $c->{$t}->{"file/".lc($2)} = $1;
	} elsif (/^\s*rem\s+discid\s+([0-9A-Fa-f]{8})\s*$/i) {
	    $c->{$t}->{discid_cue} = $1;
	} elsif (/^\s*index\s+(\d+)\s+(\d\d):(\d\d):(\d\d)\s*$/i) {
	    my ($i, $m, $s, $f) = ("index$1", 0+$2, 0+$3, 0+$4);
	    use integer;
	    $c->{$t}->{$i} = {h=>$m / 60, m=>$m % 60, s=>$s};
	    no integer;
	    die "invalid number of seconds for track $t: ".str($_)
		if $s > 59;
	    die "invalid number of frames for track $t: ".str($_)
		if $f > 74;
	    # Audio CDs supply position in the MSF format, i.e.
	    # minutes:seconds.frame_no, with each frame holding
	    # 13 and 1/3 milliseconds of audio data (there are
	    # 75 frames per second). In order to pass these
	    # positions to ffmpeg's -ss and -to parameters, we
	    # need to convert them to milliseconds and round up.
	    use integer;
	    $c->{$t}->{$i}->{ms_floor} = 1000 * $f / 75;
	    $c->{$t}->{$i}->{ms_ceil} = (1000 * $f + 74) / 75;
	    # Track offset in frames:
	    $c->{$t}->{$i}->{offs} = ($m * 60 + $s) * 75 + $f;
	} elsif (/^\s*track\s+(\d+)\s+([^\r\n]*\S)\s*$/i) {
	    $t = 0 + $1;
	    die "invalid track number - $t\n" if $t < 1;
	    if (not exists $c->{$t}) {
		# add new track number to total and max:
		if (not exists $c->{disc}->{tracks}) {
		    $c->{disc}->{tracks} = 1;
		} else {
		    $c->{disc}->{tracks}++;
		};
		$c->{disc}->{maxtrack} = $t
		    if not exists $c->{disc}->{maxtrack}
			or $t > $c->{disc}->{maxtrack};
	    };
	    $c->{$t}->{type} = lc($2);
	} elsif (/^\s*flags\s+([^\r\n]*\S)\s*$/i) {
	    # XXX ignore
	} else {
	    warn "unrecognized .cue line: $_";
	};
    };
    close $cue_fd;
    # validate .cue data:
    die "no tracks found in $cue_fname_\n"
	if not exists $c->{disc}->{maxtrack};
    die "max track no != number of tracks\n"
	if $c->{disc}->{maxtrack} != $c->{disc}->{tracks};
    # generate CDDB_dinfo-style dtitle:
    put_together_dtitle $c->{disc};
    # use "cue" as CDDB genre (NOT dgenre):
    $c->{disc}->{genre} = "cue";
    # all tracks (even non-audio) must have index01 field:
    foreach $t (grep {$_ ne "disc"} keys %$c) {
	die "no index01 defined for track $t\n"
	    if not exists $c->{$t}->{index01};
	# generate CDDB_dinfo-style ttitles:
	if ($c->{$t}->{type} eq "audio"
		and defined $c->{$t}->{_title}) {
	    # .cue files do have separate PERFORMER entries for tracks,
	    # even when all track performers are the same as the disc
	    # performer:
	    $c->{disc}->{ttitles}->[$t - 1] =
		(defined($c->{$t}->{_performer}) and
		    (not defined($c->{disc}->{_performer}) or
			$c->{disc}->{_performer}
			ne $c->{$t}->{_performer})) ?
		double_slashes($c->{$t}->{_performer})
		." / ".double_slashes($c->{$t}->{_title})
		: double_slashes $c->{$t}->{_title};
	};
    };
    calculate_discid($c, $ape_fname);
    return $c;
};

sub get_choice_or_exit() {
    my $choice = <STDIN>;
    if (not defined $choice) {
	# EOF / Ctrl-D
	print "\n";
	exit 1;
    };
    $choice = decode($loc_charenc, $choice);
    chomp $choice;
    return $choice;
};

sub split_track_titles($) {
    my ($dinfo) = @_;
    if (defined $dinfo->{ttitles}) {
	for (my $i = 0; $i < scalar(@{$dinfo->{ttitles}}); $i++) {
	    if (defined $dinfo->{ttitles}->[$i]) {
		if ($dinfo->{ttitles}->[$i] =~ m{^(.*) / (.*)$}) {
		    $dinfo->{_tracks}->[$i]->{_performer} =
			halve_slashes $1;
		    $dinfo->{_tracks}->[$i]->{_title} =
			halve_slashes $2;
		} else {
		    $dinfo->{_tracks}->[$i]->{_title} =
			halve_slashes $dinfo->{ttitles}->[$i];
		};
	    };
	};
    };
};

# Edit disc genre, year, performer, title and titles for all audio
# tracks (as indicated by .cue track type in the second parameter).
sub edit_disc_info($$) {
    my ($dinfo, $c) = @_;
    # set autoflush on STDOUT:
    my $oldsel = select(STDOUT); $| = 1; select($oldsel);
    # Edit disc genre:
    printf "Disc genre [%s]: ", str $dinfo->{dgenre};
    my $choice = get_choice_or_exit();
    if ($choice ne "") {
	$dinfo->{dgenre} = $choice;
    } elsif (not defined $dinfo->{dgenre}) {
	die "Disc genre is required\n";
    };
    # Edit disc year:
    printf "Disc year [%s]: ", str $dinfo->{dyear};
    $choice = get_choice_or_exit();
    if ($choice =~ /^\d{4}$/) {
	$dinfo->{dyear} = $choice;
    } elsif ($choice ne "") {
	die "Invalid disc year - ".str($choice)."\n";
    } elsif (not defined $dinfo->{dyear}) {
	die "Disc year is required\n";
    };
    # Edit disc performer:
    printf "Disc performer [%s]: ", str $dinfo->{_performer};
    $choice = get_choice_or_exit();
    if ($choice ne "") {
	$dinfo->{_performer} = $choice;
    } elsif (not defined $dinfo->{_performer}
	    or $dinfo->{_performer} eq "") {
	die "Disc performer is required\n";
    };
    # Edit disc title:
    printf "Disc title [%s]: ", str $dinfo->{_title};
    $choice = get_choice_or_exit();
    if ($choice ne "") {
	$dinfo->{_title} = $choice;
    } elsif (not defined $dinfo->{_title}
	    or $dinfo->{_title} eq "") {
	die "Disc title is required\n";
    };
    # Put together dtitle anew, because _title and/or _performer might
    # have been changed:
    put_together_dtitle $dinfo;
    # Edit track titles (performers/titles):
    foreach my $t (sort {$a <=> $b} grep {$_ ne "disc"
		and $c->{$_}->{type} eq "audio"} keys %$c) {
	my $tt = $dinfo->{ttitles}->[$t - 1];
	my $k = (defined $tt and $tt =~ m{^(.*) / (.*)$}) ?
	    "performer / title" : "title";
	printf "Track %02i %s [%s]: ", $t, $k, str $tt;
	$choice = get_choice_or_exit();
	if ($choice ne "") {
	    $dinfo->{ttitles}->[$t - 1] = $choice;
	} elsif (not defined $tt) {
	    die sprintf "Track %02i %s is required\n", $t, $k;
	};
    };
    # ttitles might have been edited, split them into _tracks anew:
    split_track_titles $dinfo;
};

sub split_dtitle($) {
    my ($dinfo) = @_;
    if (defined($dinfo->{dtitle})) {
	if ($dinfo->{dtitle} =~ m{^(.*) / (.*)$}) {
	    $dinfo->{_performer} = halve_slashes $1;
	    $dinfo->{_title} = halve_slashes $2;
	} else {
	    $dinfo->{_title} = halve_slashes $dinfo->{dtitle};
	};
    };
};

sub print_disc_info($$;$$) {
    my ($disc_no, $dinfo, $print_tracks, $dbgenre) = @_;
    printf "%3i. %s: %s, %s - %s - %s\n",
	$disc_no, $dinfo->{discid},
	str(defined($dbgenre) ? $dbgenre : $dinfo->{dgenre}),
	(defined($dinfo->{dyear}) ? sprintf("%04i", $dinfo->{dyear})
	    : "????"),
	str($dinfo->{_performer}),
	str($dinfo->{_title});
    if ($print_tracks and defined $dinfo->{_tracks}) {
	for (my $i = 0; $i < scalar(@{$dinfo->{_tracks}}); $i++) {
	    printf "    %02i. %s - %s\n", $i + 1, str(
		defined $dinfo->{_tracks}->[$i]->{_performer} ?
		$dinfo->{_tracks}->[$i]->{_performer} :
		$dinfo->{_performer}),
		str($dinfo->{_tracks}->[$i]->{_title});
	};
    };
};

# Write CDDB disc info into ~/.cddb/$genre/$discid file.
# The written cache file approximately follows CDDB xmcd format.
sub write_cddb_disc_info_cache($) {
    my ($dinfo) = @_;
    # "genre" and "discid" fields are required:
    defined $dinfo->{$_} or die "Disc $_ not defined\n"
	foreach qw(discid genre);
    die "Invalid disc genre ".str($dinfo->{genre})."\n"
	if $dinfo->{genre} !~ /\A[a-z_-]+\z/;
    # Find user's home directory:
    my $homedir = (defined $ENV{HOME} and $ENV{HOME} ne "") ?
	$ENV{HOME} : $ENV{LOGDIR};
    return undef if not defined $homedir or $homedir eq "";
    # Create ~/.cddb subdirectory if it doesn't exist:
    mkdir "$homedir/.cddb" or die "Cannot create ~/.cddb - $!\n"
	if not -d "$homedir/.cddb";
    # Create ~/.cddb/$genre subdirectory if it doesn't exist:
    mkdir "$homedir/.cddb/$dinfo->{genre}"
	    or die "Cannot create ~/.cddb/".str($dinfo->{genre})
		." - $!\n"
	if not -d "$homedir/.cddb/$dinfo->{genre}";
    foreach my $discid (split /\s*,\s*/, $dinfo->{discid}) {
	my $cache_fname = "$homedir/.cddb/$dinfo->{genre}/$discid";
	open my $cache_fh, ">", $cache_fname
	    or die "Cannot create ".str($cache_fname)." - $!\n";
	defined $dinfo->{$_} and printf {$cache_fh} "%s=%s\n",
		uc($_), encode("utf8", $dinfo->{$_})
	    foreach qw(discid dtitle dyear dgenre);
	for (my $i = 0; defined $dinfo->{ttitles}
		and $i < scalar(@{$dinfo->{ttitles}}); $i++) {
	    printf {$cache_fh} "TTITLE%i=%s\n", $i,
		    encode("utf8", $dinfo->{ttitles}->[$i])
		if defined $dinfo->{ttitles}->[$i];
	};
	close $cache_fh;
    };
};

# Read 1st matching cached info from ~/.cddb/$genre/$discid file.
sub read_cddb_disc_info_cache($) {
    my ($dinfo) = @_;
    # "genre" and "discid" fields are required:
    defined $dinfo->{$_} or die "Disc $_ not defined\n"
	foreach qw(discid genre);
    die "Invalid disc genre ".str($dinfo->{genre})."\n"
	if $dinfo->{genre} !~ /\A[a-z_-]+\z/;
    # Find user's home directory:
    my $homedir = (defined $ENV{HOME} and $ENV{HOME} ne "") ?
	$ENV{HOME} : $ENV{LOGDIR};
    return undef if not defined $homedir or $homedir eq "";
    foreach my $discid (split /\s*,\s*/, $dinfo->{discid}) {
	my $cache_fname = "$homedir/.cddb/$dinfo->{genre}/$discid";
	if (-f $cache_fname or -l $cache_fname) {
	    open my $cache_fh, "<", $cache_fname
		or die "Cannot open ".str($cache_fname)." - $!\n";
	    my $ci;
	    while (<$cache_fh>) {
		$_ = decode("utf8", $_);
		$ci->{lc($1)} = $2
		    if /\A\s*([^=]*[^=\s])\s*=\s*([^\r\n]*\S)\s\z/;
	    };
	    close $cache_fh;
	    defined $ci->{$_} and $dinfo->{$_} = $ci->{$_}
		foreach qw(dtitle dyear dgenre);
	    /^ttitle(\d+)$/ and $dinfo->{ttitles}->[$1] = $ci->{$_}
		foreach keys %$ci;
	    split_dtitle($dinfo);
	    split_track_titles($dinfo);
	    last;
	};
    };
};

sub get_and_edit_cue_and_cddb_data($$;$) {
    my ($c, $ape_fname, $opts) = @_;
    my (@dinfos, $chosen_disc_no);
    # Read cached data for .cue dinfo unless -c option is given:
    read_cddb_disc_info_cache($c->{disc}) if not $opts->{c};
    push @dinfos, $c->{disc};
    # Append disc_infos from CDDB unless -d option is specified:
    if (not defined $opts->{d}) {
	# Load CDDB.pm library at runtime:
	eval {
	    require CDDB;
	    import  CDDB;
	};
	die "Perl CDDB module is missing\n"
	    if defined $@ and $@ ne "";
	my $cddb = new CDDB(
	    Host  => 'freedb.freedb.org',
	    Login => 'nobody',
	) or die "Cannot init CDDB - $!\n";
	$cddb->{hostname} = "localhost";
	# query CDDB server:
	printf "Get  %s: %s %s...\n", $c->{disc}->{discid},
	    join(" ", @{$c->{disc}->{track_offsets}}),
	    $c->{disc}->{ape_time};
	my @discs = $cddb->get_discs(
	    $c->{disc}->{discid},
	    $c->{disc}->{track_offsets},
	    $c->{disc}->{ape_time}
	);
	# get detailed info for each CDDB disc:
	foreach my $disc (@discs) {
	    my ($dbgenre, $dbid, $dbperformertitle) = @$disc;
	    my $dinfo = $cddb->get_disc_details($dbgenre, $dbid);
	    split_dtitle($dinfo);
	    split_track_titles($dinfo);
	    push @dinfos, $dinfo;
	};
    };
    # print all disc infos:
    for (my $i = 0; $i < scalar(@dinfos); $i++) {
	print_disc_info($i, $dinfos[$i], 0, $dinfos[$i]->{genre});
    };
    # set autoflush on STDOUT:
    my $oldsel = select(STDOUT); $| = 1; select($oldsel);
    # select one disc from several:
    if (scalar(@dinfos) > 1 and not defined $opts->{n}) {
	printf "Select a disc data (0-%i) [1]: ", $#dinfos;
	my $choice = get_choice_or_exit();
	if ($choice =~ /^\d+$/ and $choice <= $#dinfos) {
	    $chosen_disc_no = $choice;
	} elsif ($choice eq "") {
	    $chosen_disc_no = 1;
	} else {
	    die "invalid disc data index - ".str($choice)."\n";
	};
    } else {
	$chosen_disc_no = (defined $opts->{n}) ? $opts->{n} : 0;
    };
    die "Invalid selected disc $chosen_disc_no\n"
	if not defined $dinfos[$chosen_disc_no];
    printf "Selected disc %i:\n", $chosen_disc_no;
    # read cached info for the chosen disc unless cache reading is
    # disabled by option -c:
    read_cddb_disc_info_cache($dinfos[$chosen_disc_no])
	if not $opts->{c};
    print_disc_info($chosen_disc_no, $dinfos[$chosen_disc_no], 1);
    # edit the disc info if requested by user:
    if (not defined $opts->{n}) {
	printf "Do you want to edit the disc info? (y/n) [n]: ";
	my $choice = get_choice_or_exit();
	if ($choice eq "y") {
	    edit_disc_info($dinfos[$chosen_disc_no], $c);
	    split_track_titles($dinfos[$chosen_disc_no]);
	    print_disc_info($chosen_disc_no, $dinfos[$chosen_disc_no], 1);
	    write_cddb_disc_info_cache($dinfos[$chosen_disc_no]);
	};
    };
    return $dinfos[$chosen_disc_no];
};

sub encode_tracks($$$$) {
    my ($c, $dinfo, $ape_fname, $opts) = @_;
    my $dyear04 = (defined $dinfo->{dyear}) ?
	(sprintf "%04i", $dinfo->{dyear}) : undef;
    my $dperformer_ = str_ $dinfo->{_performer};
    my $dtitle_ = str_ $dinfo->{_title};
    my $dgenre_ = str_ $dinfo->{dgenre};
    my $disc_dname_;
    # generate meaningful disc_name_ even if year/title/performer isn't
    # defined:
    if (defined $dtitle_) {
	$disc_dname_ = (defined $dperformer_) ?
	    $dperformer_." - ".$dtitle_ : $dtitle_;
	$disc_dname_ = $dyear04." - ".$disc_dname_
	    if defined $dyear04;
	$disc_dname_ =~ s!/!|!g;
    } else {
	$disc_dname_ = str $ape_fname;
	$disc_dname_ = s/\A.*\///;
	$disc_dname_ = s/\.(ape|flac|wav)\z//i;
    };
    if (not -d $disc_dname_) {
	mkdir $disc_dname_ or die "cannot mkdir $disc_dname_ - $!";
    };
    foreach my $t (sort {$a <=> $b} grep {$_ ne "disc"
    and $c->{$_}->{type} eq "audio"} keys %$c) {
	my $tperformer_ =
	    defined $dinfo->{_tracks}->[$t - 1]->{_performer} ?
	    str($dinfo->{_tracks}->[$t - 1]->{_performer}) :
	    $dperformer_;
	my $ttitle_ = str_ $dinfo->{_tracks}->[$t - 1]->{_title};
	my $t02 = sprintf "%02i", $t;
	# generate meaningful track name when title/performer isn't
	# defined:
	my $track_base_;
	if (defined $ttitle_) {
	    $track_base_ = (defined $tperformer_) ?
		"$t02. $tperformer_ - $ttitle_" : "$t02. $ttitle_";
	} else {
	    $track_base_ = $t02;
	};
	$track_base_ =~ s!/!|!g;
	my ($track_wav_, $track_mp3_) = (
	    "$disc_dname_/$track_base_.wav",
	    "$disc_dname_/$track_base_.mp3");
	my @ffmpeg = ("ffmpeg", "-i", $ape_fname,
	    "-ss", (sprintf "%02i:%02i:%02i.%03i",
		$c->{$t}->{index01}->{h},
		$c->{$t}->{index01}->{m},
		$c->{$t}->{index01}->{s},
		$c->{$t}->{index01}->{ms_ceil}));
	if (exists $c->{$t + 1}) {
	    my $i = exists $c->{$t + 1}->{index00} ? "index00"
		: "index01";
	    push @ffmpeg, "-to";
	    push @ffmpeg, (sprintf "%02i:%02i:%02i.%03i",
		$c->{$t + 1}->{$i}->{h},
		$c->{$t + 1}->{$i}->{m},
		$c->{$t + 1}->{$i}->{s},
		$c->{$t + 1}->{$i}->{ms_floor});
	};
	# push @ffmpeg, "-metadata", "date=$dyear04";
	# push @ffmpeg, "-metadata", "album=$dtitle_";
	# push @ffmpeg, "-metadata", "genre=$dgenre_";
	# push @ffmpeg, "-metadata", "track=$t02";
	# push @ffmpeg, "-metadata", "artist=$tperformer_";
	# push @ffmpeg, "-metadata", "title=$ttitle_";
	# push @ffmpeg, "-metadata", "albumartist=$dperformer_"
	#    if defined $dinfo->{_tracks}->[$t - 1]->{_performer};
	push @ffmpeg, ("-y", $track_wav_);
	print join(" ", @ffmpeg)."\n";
	my $r = system {$ffmpeg[0]} @ffmpeg;
	die "ffmpeg error - $!\n" if $r < 0;
	die "ffmpeg error $?\n" if $r != 0;
	my @lame = ("lame", "--tn", $t);
	# Add bitrate/quality options:
	if (defined $opts->{q}) {
	    push @lame, "-V", $opts->{q};
	} elsif (defined $opts->{b}) {
	    push @lame, "-b", $opts->{b};
	} else {
	    push @lame, "-V2";
	};
	push @lame, "--ty", $dyear04 if defined $dyear04;
	push @lame, "--tl", $dtitle_ if defined $dtitle_;
	push @lame, "--tt", $ttitle_ if defined $ttitle_;
	push @lame, "--tg", $dgenre_ if defined $dgenre_;
	push @lame, "--ta", $tperformer_ if defined $tperformer_;
	if (defined $dinfo->{_tracks}->[$t - 1]->{_performer}
		and defined $dperformer_) {
	    push @lame, "--tv", "TPE2=$dperformer_";
	} else {
	    push @lame, "--id3v1-only";
	};
	push @lame, $track_wav_, $track_mp3_;
	print join(" ", @lame)."\n";
	$r = system {$lame[0]} @lame;
	die "lame error - $!\n" if $r < 0;
	die "lame error $?\n" if $r != 0;
	unlink $track_wav_ or die "cannot unlink $track_wav_ - $!\n";
    };
};

# Return (locale-decoded) list of all other files/symlinks residing in
# the same subdir as the given file.
sub adjacent_files($) {
    my ($f) = @_;
    my $dn = ($f =~ m!\A(.*/)!) ? $1 : $f;
    opendir(my $dh, $dn) or die "Cannot open ".str($dn)." - $!\n";
    my @r = grep {$_ ne $f and -f $_ || -l $_}
	map {$dn.decode($loc_charenc, $_)} readdir $dh;
    closedir $dh;
    return @r;
};

# For the given 2 strings return number of matching characters at the
# left.
sub lmatch($$) {
    my ($i, $s1, $s2) = (0, @_);
    for (; $i < length($s1) and $i < length($s2); $i++) {
	return $i if substr($s1, $i, 1) ne substr($s2, $i, 1);
    };
    return $i;
};


sub usage($) {
    print "USAGE: $0 [opts] disc1.cue [disc2.cue ...]\n";
    print "  where opts are:\n";
    print "    -b N  encode mp3's with constant bitrate of Nkbits\n";
    print "    -c    don't read ~/.cddb/<genre>/<discid> cache\n";
    print "    -d    don't query CDDB server\n";
    print "    -n N  select Nth cue/CDDB disc info & don't edit\n";
    print "    -q L  encode mp3's with VBR at quality level L\n";
    exit $_[0];
};

# Parse options:
my $opts = {};
my $opts_ok = getopts("b:cdn:q:", $opts);
foreach my $o (qw(b q)) {
    die "Invalid \"-$o $opts->{$o}\" option value\n"
	if defined $opts->{$o} and $opts->{$o} !~ /\A\d+\z/;
};
foreach my $o (qw(n)) {
    die "Invalid \"-$o $opts->{$o}\" option value\n"
	if defined $opts->{$o} and $opts->{$o} !~ /\A-?\d+\z/;
};
usage(1) if not @ARGV or not $opts_ok;

no warnings "exec";
die "\"ffmpeg\" not found on this system\n"
    if system("ffmpeg -version >/dev/null 2>&1") != 0;
die "\"lame\" not found on this system\n"
    if system("lame --version >/dev/null 2>&1") != 0;
use warnings;

foreach my $cue_fname_ (@ARGV) {
    my $cue_fname = decode($loc_charenc, $cue_fname_);
    die "$cue_fname_ doesn't exist\n" if not -e $cue_fname;
    my $ape_fname;
    foreach my $x (sort {
	    my $r = lmatch($b, $cue_fname)
		<=> lmatch($a, $cue_fname);
	    return $r ? $r : $b cmp $a
	} adjacent_files $cue_fname) {
	if ($x =~ /\.(ape|flac|wav)/i) {
	    $ape_fname = $x;
	    last;
	};
    };
    die "No .ape/.flac/.wav file found for $cue_fname_\n"
	if not defined $ape_fname;
    (my $cue_bname = $cue_fname) =~ s!\A.*/!!;
    (my $ape_bname = $ape_fname) =~ s!\A.*/!!;
    printf "Splitting  %s  +  %s\n", str($cue_bname), str($ape_bname);
    my $c = parse_cue_ape($cue_fname, $ape_fname);
    my $dinfo = get_and_edit_cue_and_cddb_data($c, $ape_fname, $opts);
    encode_tracks($c, $dinfo, $ape_fname, $opts);
};

# vi:set sw=4 noet ts=8 tw=71:
