#!/usr/bin/env perl

use strict;
use warnings;
use Data::Dumper;

# Parse .cue contents from the given file descriptor.
# Returns hash:
# {disc=>{performer=>..., title=>...},
#   1=>{performer=>..., title=>...,
#     index01=>{m=>..., s=>..., f=>..., ms_ceil=>...},
#     ...
#   },
#   2=>{...},
#   ...
# }
sub parse_cue($) {
    my ($fd) = @_;
    my $r;
    my $t = "disc";
    while (<$fd>) {
	if (/^\s*title\s+"(.*)"\s*$/i) {
	    my $title = $1;
	    $r->{$t}->{title} = $title
		if $title !~ /^\s*track\s*\d+\s*$/i;
	} elsif (/^\s*performer\s+"(.*)"\s*$/i) {
	    $r->{$t}->{performer} = $1;
	} elsif (/^\s*rem\s+date\s+(\d+)\s*$/i) {
	    $r->{$t}->{year} = $1;
	} elsif (/^\s*rem\s+genre\s+("(.*)"|([^\r\n]*\S))\s*$/i) {
	    $r->{$t}->{genre} = (defined $2) ? $2 : $3;
	} elsif (/^\s*rem\s+comment\s+([^\r\n]*\S)\s*$/i) {
	    $r->{$t}->{comment} = $1;
	} elsif (/^\s*file\s+"(.*)"\s+(wave)\s*$/i) {
	    $r->{$t}->{"file/".lc($2)} = $1;
	} elsif (/^\s*rem\s+discid\s+(([0-9A-F]{2})([0-9A-F]{4})
	([0-9A-F]{2}))\s*$/ix) {
	    $r->{$t}->{discid} = $1;
	    $r->{$t}->{discid_cksum} = hex($2);
	    $r->{$t}->{discid_time} = hex($3);
	    $r->{$t}->{discid_tracks} = hex($4);
	} elsif (/^\s*index\s+(\d+)\s+0*(\d+):0*(\d+):0*(\d+)\s*$/i) {
	    my ($i, $m, $s, $f) = ("index$1", $2, $3, $4);
	    $r->{$t}->{$i} = {m=>$m, s=>$s, f=>$f};
	    die "invalid number of seconds for track $t: $_"
		if $s > 59;
	    die "invalid number of frames for track $t: $_"
		if $f > 74;
	    # Audio CDs supply position in the MSF format, i.e.
	    # minutes:seconds.frame_no, with each frame holding
	    # 13 and 1/3 milliseconds of audio data (there are
	    # 75 frames per second). In order to pass these
	    # positions to ffmpeg's -ss and -to parameters, we
	    # need to convert them to milliseconds and round up.
	    $r->{$t}->{$i}->{ms} = 1000.0 * $f / 75;
	    use integer;
	    $r->{$t}->{$i}->{ms_ceil} = (1000 * $f + 74) / 75;
	    # Track offset in frames:
	    $r->{$t}->{$i}->{offs} = ($m * 60 + $s) * 75 + $f;
	} elsif (/^\s*track\s+(0*(\d+))\s+([^\r\n]*\S)\s*$/i) {
	    $t = $2;
	    if (not exists $r->{$t}) {
		# add new track number to total and max:
		if (not exists $r->{disc}->{tracks}) {
		    $r->{disc}->{tracks} = 1;
		} else {
		    $r->{disc}->{tracks}++;
		};
		$r->{disc}->{maxtrack} = $t
		    if not exists $r->{disc}->{maxtrack}
			or $t > $r->{disc}->{maxtrack};
	    };
	    $r->{$t}->{track} = $1;
	    $r->{$t}->{type} = $3;
	} else {
	    warn "unrecognized .cue line: $_";
	};
    };
    # find tracks without title/performer:
    foreach $t (grep {$_ ne "disc"} keys %$r) {
	if (not exists $r->{$t}->{title}
	or not exists $r->{$t}->{performer}
	and not exists $r->{disc}->{performer}) {
	    $r->{disc}->{untitled_tracks}->{$t} = 1;
	};
    };
    return $r;
};

foreach my $f (@ARGV) {
    die "invalid filename - $f\n" if not $f =~ /\A(.*)\.(ape|cue)\z/i;
    my ($ape_fname, $cue_fname) = ("$1.ape", "$1.cue");
    foreach my $fname ($ape_fname, $cue_fname) {
	die "$fname doesn't exist\n" if not -e $fname;
    };
    open (my $cue_fd, "<", $cue_fname)
	or die "cannot open $cue_fname - $!\n";
    my $c = parse_cue($cue_fd);
    print Data::Dumper->Dump([$c]);
    close $cue_fd;
};

# vi:set sw=4 noet ts=8 tw=71:
