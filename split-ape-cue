#!/usr/bin/env perl

use strict;
use warnings;
use Encode qw(decode encode);
use Data::Dumper;

sub get_loc_charenc() {
    my $charenc;
    # the simplest way: trailing charmap in LANG/etc:
    foreach my $k (qw(LC_ALL LC_CTYPE LANG)) {
	return $2
	    if defined $ENV{$k} and $ENV{$k} =~ /^([^.]+)\.(.*)$/;
    };
    # nl_langinfo (3)      - query language and locale information,
    # its perl counterpart is implemented as I18N::Langinfo:
    eval {
	require I18N::Langinfo;
	import  I18N::Langinfo;
	$charenc = I18N::Langinfo::langinfo(
	    I18N::Langinfo::CODESET());
    };
    return $charenc if defined $charenc and $charenc ne "";
    # try executing `locale charmap`:
    eval {$charenc = `locale charmap`};
    chomp $charenc if defined $charenc;
    return $charenc if defined $charenc and $charenc ne "";
    # assume utf8 by default:
    return "utf8";
};

# XXX : $loc_charenc is a global variable.
my $loc_charenc = get_loc_charenc();

# Parse .cue contents from the given file descriptor.
# Returns hash:
# {disc=>{performer=>..., title=>...},
#   1=>{performer=>..., title=>...,
#     index01=>{m=>..., s=>..., f=>..., ms_ceil=>...},
#     ...
#   },
#   2=>{...},
#   ...
# }
sub parse_cue($) {
    my ($cue_fname) = @_;
    open (my $cue_fd, "<", $cue_fname)
	or die "cannot open $cue_fname - $!\n";
    my $r;
    my $t = "disc";
    while (<$cue_fd>) {
	$_ = decode($loc_charenc, $_);
	if (/^\s*title\s+"(.*)"\s*$/i) {
	    my $title = $1;
	    $r->{$t}->{title} = $title
		if $title !~ /^\s*track\s*\d+\s*$/i;
	} elsif (/^\s*performer\s+"(.*)"\s*$/i) {
	    $r->{$t}->{performer} = $1;
	} elsif (/^\s*rem\s+date\s+(\d+)\s*$/i) {
	    $r->{$t}->{year} = $1;
	} elsif (/^\s*rem\s+genre\s+("(.*)"|([^\r\n]*\S))\s*$/i) {
	    $r->{$t}->{genre} = (defined $2) ? $2 : $3;
	} elsif (/^\s*rem\s+comment\s+([^\r\n]*\S)\s*$/i) {
	    $r->{$t}->{comment} = $1;
	} elsif (/^\s*file\s+"(.*)"\s+(wave)\s*$/i) {
	    $r->{$t}->{"file/".lc($2)} = $1;
	} elsif (/^\s*rem\s+discid\s+(([0-9A-F]{2})([0-9A-F]{4})
	([0-9A-F]{2}))\s*$/ix) {
	    $r->{$t}->{discid} = $1;
	    $r->{$t}->{discid_cksum} = hex($2);
	    $r->{$t}->{discid_time} = hex($3);
	    $r->{$t}->{discid_tracks} = hex($4);
	} elsif (/^\s*index\s+(\d+)\s+0*(\d+):0*(\d+):0*(\d+)\s*$/i) {
	    my ($i, $m, $s, $f) = ("index$1", $2, $3, $4);
	    use integer;
	    $r->{$t}->{$i} = {h=>$m / 60, m=>$m % 60, s=>$s, f=>$f};
	    no integer;
	    die "invalid number of seconds for track $t: $_"
		if $s > 59;
	    die "invalid number of frames for track $t: $_"
		if $f > 74;
	    # Audio CDs supply position in the MSF format, i.e.
	    # minutes:seconds.frame_no, with each frame holding
	    # 13 and 1/3 milliseconds of audio data (there are
	    # 75 frames per second). In order to pass these
	    # positions to ffmpeg's -ss and -to parameters, we
	    # need to convert them to milliseconds and round up.
	    $r->{$t}->{$i}->{ms} = 1000.0 * $f / 75;
	    use integer;
	    $r->{$t}->{$i}->{ms_ceil} = (1000 * $f + 74) / 75;
	    # Track offset in frames:
	    $r->{$t}->{$i}->{offs} = ($m * 60 + $s) * 75 + $f;
	} elsif (/^\s*track\s+(0*(\d+))\s+([^\r\n]*\S)\s*$/i) {
	    $t = $2;
	    die "invalid track number - $t\n" if $t == 0;
	    if (not exists $r->{$t}) {
		# add new track number to total and max:
		if (not exists $r->{disc}->{tracks}) {
		    $r->{disc}->{tracks} = 1;
		} else {
		    $r->{disc}->{tracks}++;
		};
		$r->{disc}->{maxtrack} = $t
		    if not exists $r->{disc}->{maxtrack}
			or $t > $r->{disc}->{maxtrack};
	    };
	    $r->{$t}->{track} = $1;
	    $r->{$t}->{type} = lc($3);
	} elsif (/^\s*flags\s+([^\r\n]*\S)\s*$/i) {
	    # XXX ignore
	} else {
	    warn "unrecognized .cue line: $_";
	};
    };
    close $cue_fd;
    die "no tracks found in $cue_fname\n"
	if not exists $r->{disc}->{maxtrack};
    die "max track no != num,ber of tracks\n"
	if $r->{disc}->{maxtrack} != $r->{disc}->{tracks};
    # find tracks without title/performer:
    foreach $t (grep {$_ ne "disc"} keys %$r) {
	die "no index01 defined for track $t\n"
	    if not exists $r->{$t}->{index01};
	if ($r->{$t}->{type} eq "audio"
	and (not exists $r->{$t}->{title}
	    or not exists $r->{$t}->{performer}
	    and not exists $r->{disc}->{performer})) {
	    $r->{disc}->{untitled_tracks}->{$t} = 1;
	};
    };
    return $r;
};

sub sum_digits_base_n($$) {
    my ($x, $base) = @_;
    my $s = 0;
    use integer;
    while ($x > 0) {
	$s = $s + ($x % $base);
	$x = $x / $base;
    };
    return $s;
};

sub get_choice_or_exit() {
    my $choice = <STDIN>;
    if (not defined $choice) {
	# EOF / Ctrl-D
	print "\n";
	exit 1;
    };
    $choice = decode($loc_charenc, $choice);
    chomp $choice;
    return $choice;
};

sub validate_disc_info($) {
    my ($dinfo) = @_;
    foreach my $k (("disc length", "dtitle", "dyear",
    "dgenre", "offsets", "ttitles")) {
	die "missing disc $k\n" if not defined $dinfo->{$k};
    };
    die "invalid disc length - ".$dinfo->{"disc length"}."\n"
	if $dinfo->{"disc length"} !~ /(\d+)/;
    $dinfo->{_dlength} = $1;
    die "invalid disc year - $dinfo->{dyear}\n"
	if $dinfo->{dyear} !~ /^\d{4}$/;
    die "invalid disc performer / title - $dinfo->{dtitle}\n"
	if $dinfo->{dtitle} !~ m{^(.*) / (.*)$};
    ($dinfo->{_performer}, $dinfo->{_title}) = ($1, $2);
};

sub edit_disc_info($) {
    my ($dinfo) = @_;
    printf "Disc genre [%s]: ",
	encode($loc_charenc, $dinfo->{dgenre});
    my $choice = get_choice_or_exit();
    $dinfo->{genre} = $choice if $choice ne "";
    printf "Disc year [%s]: ",
	encode($loc_charenc, $dinfo->{dyear});
    $choice = get_choice_or_exit();
    if ($choice =~ /^\d{4}$/) {
	$dinfo->{year} = $choice;
    } elsif ($choice ne "") {
	die "invalid year - $choice\n";
    };
    printf "Disc performer [%s]: ",
	encode($loc_charenc, $dinfo->{_performer});
    $choice = get_choice_or_exit();
    $dinfo->{_performer} = $choice if $choice ne "";
    printf "Disc title [%s]: ",
	encode($loc_charenc, $dinfo->{_title});
    $choice = get_choice_or_exit();
    $dinfo->{_title} = $choice if $choice ne "";
    for (my $i = 0; $i < scalar(@{$dinfo->{ttitles}}); $i++) {
	if ($dinfo->{ttitles}->[$i] =~ m{^(.*) / (.*)$}) {
	    printf "Track %02i performer / title [%s]: ", $i + 1,
		encode($loc_charenc, $dinfo->{ttitles}->[$i]);
	} else {
	    printf "Track %02i title [%s]: ", $i + 1,
		encode($loc_charenc, $dinfo->{ttitles}->[$i]);
	};
	$choice = get_choice_or_exit();
	$dinfo->{ttitles}->[$i] = $choice if $choice ne "";
    };
};

sub split_track_performer_title($) {
    my ($dinfo) = @_;
    for (my $i = 0; $i < scalar(@{$dinfo->{ttitles}}); $i++) {
	if ($dinfo->{ttitles}->[$i] =~ m{^(.*) / (.*)$}) {
	    $dinfo->{_tracks}->[$i]->{_performer} = $1;
	    $dinfo->{_tracks}->[$i]->{_title} = $2;
	} else {
	    $dinfo->{_tracks}->[$i]->{_title} =
		$dinfo->{ttitles}->[$i];
	};
    };
};

sub print_disc_info($;$$) {
    my ($dinfo, $print_tracks, $dbgenre) = @_;
    printf "%3i. %s: %s, %04i - %s - %s\n",
	$dinfo->{_disc_no} + 1,
	$dinfo->{discid},
	encode($loc_charenc, defined($dbgenre) ? $dbgenre
	    : $dinfo->{dgenre}),
	$dinfo->{dyear},
	encode($loc_charenc, $dinfo->{_performer}),
	encode($loc_charenc, $dinfo->{_title});
    if ($print_tracks) {
	for (my $i = 0; $i < scalar(@{$dinfo->{_tracks}}); $i++) {
	    printf "    %02i. %s - %s\n", $i + 1,
		encode($loc_charenc,
		    defined $dinfo->{_tracks}->[$i]->{_performer} ?
		    $dinfo->{_tracks}->[$i]->{_performer}
		    : $dinfo->{_performer}),
		encode($loc_charenc,
		    $dinfo->{_tracks}->[$i]->{_title});
	};
    };
};

sub get_missing_data_from_cddb_or_ape($$) {
    my ($c, $ape_fname) = @_;
    if (exists $c->{disc}->{untitled_tracks} or 1) {
	# Load CDDB.pm library at runtime:
	eval {
	    require CDDB;
	    import  CDDB;
	};
	die "Perl CDDB module is missing\n"
	    if defined $@ and $@ ne "";
	my $cddb = new CDDB(
	    Host  => 'freedb.freedb.org',
	    Login => 'nobody',
	) or die "Cannot init CDDB - $!\n";
	$cddb->{hostname} = "localhost";
	use integer;
	# XXX: track01 typically starts at 2 sec (150 frames) offset:
	@{$c->{disc}->{track_offsets}} =
	    map {150 + $c->{$_}->{index01}->{offs}}
	    sort {$a <=> $b} grep {$_ ne "disc"} keys %$c;
	$c->{disc}->{offsum} = 0;
	$c->{disc}->{offsum} += sum_digits_base_n($_ / 75, 10)
	    foreach @{$c->{disc}->{track_offsets}};
	no integer;
	# detect total play time of the disc:
	if (not exists $c->{disc}->{discid_time} or 1) {
	    # fork child ffmpeg process:
	    my $ffmpeg_pid = open my $ffmpeg_out, "-|";
	    die "cannot fork: $!" if not defined $ffmpeg_pid;
	    if ($ffmpeg_pid == 0) {
		# child
		open STDERR, ">&STDOUT"
		    or die "Cannot redirect STDERR to STDOUT: $!";
		exec {"ffmpeg"} ("ffmpeg", "-i", $ape_fname)
		    or die "Cannot execute ffmpeg: $!";
	    } else {
		# parent
		while (<$ffmpeg_out>) {
		    #  Duration: 00:46:25.43, start: 0.000000, ...
		    if (/^\s*Duration:\s*(\d\d):(\d\d):(\d\d)
		    \.\d+,/ix) {
			$c->{disc}->{ape_time} =
			    ($1 * 60 + $2) * 60 + $3;
		    }
		};
		close $ffmpeg_out;
	    };
	};
	# calculate discid "hash" for CDDB server:
	$c->{disc}->{discid2} = sprintf "%02x%04x%02x",
	    $c->{disc}->{offsum} % 255,
	    $c->{disc}->{ape_time},
	    $c->{disc}->{tracks};
	# query CDDB server:
	print "get  $c->{disc}->{discid2}: ".join(" ",
	    @{$c->{disc}->{track_offsets}})
	    ." $c->{disc}->{ape_time}\n";
	my @discs = $cddb->get_discs(
	    $c->{disc}->{discid2},
	    $c->{disc}->{track_offsets},
	    $c->{disc}->{ape_time}
	);
	# get detailed info for each CDDB disc:
	my ($disc_no, $dinfo, @valid_discs) = (0);
	foreach my $disc (@discs) {
	    my ($dbgenre, $dbid, $dbperformertitle) = @$disc;
	    $dinfo = $cddb->get_disc_details($dbgenre, $dbid);
	    validate_disc_info($dinfo);
	    split_track_performer_title($dinfo);
	    $dinfo->{_disc_no} = $disc_no;
	    print_disc_info($dinfo, 0, $dbgenre);
	    $valid_discs[$disc_no++] = $dinfo;
	};
	# select one disc from several:
	my $chosen_disc_no = 0;
	if (scalar(@valid_discs) > 1) {
	    my $oldsel = select(STDOUT); $| = 1; select($oldsel);
	    printf "Select a disc data (1-%i) [1]: ",
		scalar(@valid_discs);
	    my $choice = get_choice_or_exit();
	    if ($choice =~ /^\d+$/ and $choice >= 1
	    and $choice <= scalar(@valid_discs)) {
		$chosen_disc_no = $choice - 1;
	    } elsif ($choice ne "") {
		die "invalid CDDB disc number - $choice\n";
	    };
	};
	printf "Selected disc %i:\n", $chosen_disc_no + 1;
	$dinfo = $valid_discs[$chosen_disc_no];
	print_disc_info($dinfo, 1);
	# edit the disc info if requested by user:
	printf "Do you want to edit the disc info? (y/n) [n]: ";
	my $choice = get_choice_or_exit();
	if ($choice eq "y") {
	    edit_disc_info($dinfo);
	    split_track_performer_title($dinfo);
	    print_disc_info($dinfo, 1);
	};
	# pass dinfo data to $c:
	$c->{disc}->{performer} = $dinfo->{_performer};
	$c->{disc}->{title} = $dinfo->{_title};
	$c->{disc}->{year} = $dinfo->{dyear};
	$c->{disc}->{genre} = $dinfo->{dgenre};
	for (my $i = 0; $i < scalar(@{$dinfo->{_tracks}}); $i++) {
	    my $_track = $dinfo->{_tracks}->[$i];
	    $c->{$i + 1}->{title} = $_track->{_title};
	    if (defined $_track->{_performer}) {
		$c->{$i + 1}->{performer} = $_track->{_performer};
	    } else {
		undef $c->{$i + 1}->{performer};
	    };
	};
    };
};

foreach my $f (@ARGV) {
    $f = decode($loc_charenc, $f);
    die "invalid filename - $f\n"
	if not $f =~ /\A(.*)\.(ape|cue)\z/i;
    my ($ape_fname, $cue_fname) = ("$1.ape", "$1.cue");
    foreach my $fname ($ape_fname, $cue_fname) {
	die "$fname doesn't exist\n" if not -e $fname;
    };
    my $c = parse_cue($cue_fname);
    get_missing_data_from_cddb_or_ape($c, $ape_fname);
};

# vi:set sw=4 noet ts=8 tw=71:
