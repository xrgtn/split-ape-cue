#!/usr/bin/env perl

use strict;
use warnings;
use Data::Dumper;

# Parse .cue contents from the given file descriptor.
# Returns hash:
# {disc=>{performer=>..., title=>...},
#   1=>{performer=>..., title=>...,
#     index01=>{m=>..., s=>..., f=>..., ms_ceil=>...},
#     ...
#   },
#   2=>{...},
#   ...
# }
sub parse_cue($) {
    my ($cue_fname) = @_;
    open (my $cue_fd, "<", $cue_fname)
	or die "cannot open $cue_fname - $!\n";
    my $r;
    my $t = "disc";
    while (<$cue_fd>) {
	if (/^\s*title\s+"(.*)"\s*$/i) {
	    my $title = $1;
	    $r->{$t}->{title} = $title
		if $title !~ /^\s*track\s*\d+\s*$/i;
	} elsif (/^\s*performer\s+"(.*)"\s*$/i) {
	    $r->{$t}->{performer} = $1;
	} elsif (/^\s*rem\s+date\s+(\d+)\s*$/i) {
	    $r->{$t}->{year} = $1;
	} elsif (/^\s*rem\s+genre\s+("(.*)"|([^\r\n]*\S))\s*$/i) {
	    $r->{$t}->{genre} = (defined $2) ? $2 : $3;
	} elsif (/^\s*rem\s+comment\s+([^\r\n]*\S)\s*$/i) {
	    $r->{$t}->{comment} = $1;
	} elsif (/^\s*file\s+"(.*)"\s+(wave)\s*$/i) {
	    $r->{$t}->{"file/".lc($2)} = $1;
	} elsif (/^\s*rem\s+discid\s+(([0-9A-F]{2})([0-9A-F]{4})
	([0-9A-F]{2}))\s*$/ix) {
	    $r->{$t}->{discid} = $1;
	    $r->{$t}->{discid_cksum} = hex($2);
	    $r->{$t}->{discid_time} = hex($3);
	    $r->{$t}->{discid_tracks} = hex($4);
	} elsif (/^\s*index\s+(\d+)\s+0*(\d+):0*(\d+):0*(\d+)\s*$/i) {
	    my ($i, $m, $s, $f) = ("index$1", $2, $3, $4);
	    $r->{$t}->{$i} = {m=>$m, s=>$s, f=>$f};
	    die "invalid number of seconds for track $t: $_"
		if $s > 59;
	    die "invalid number of frames for track $t: $_"
		if $f > 74;
	    # Audio CDs supply position in the MSF format, i.e.
	    # minutes:seconds.frame_no, with each frame holding
	    # 13 and 1/3 milliseconds of audio data (there are
	    # 75 frames per second). In order to pass these
	    # positions to ffmpeg's -ss and -to parameters, we
	    # need to convert them to milliseconds and round up.
	    $r->{$t}->{$i}->{ms} = 1000.0 * $f / 75;
	    use integer;
	    $r->{$t}->{$i}->{ms_ceil} = (1000 * $f + 74) / 75;
	    # Track offset in frames:
	    $r->{$t}->{$i}->{offs} = ($m * 60 + $s) * 75 + $f;
	} elsif (/^\s*track\s+(0*(\d+))\s+([^\r\n]*\S)\s*$/i) {
	    $t = $2;
	    die "invalid track number - $t\n" if $t == 0;
	    if (not exists $r->{$t}) {
		# add new track number to total and max:
		if (not exists $r->{disc}->{tracks}) {
		    $r->{disc}->{tracks} = 1;
		} else {
		    $r->{disc}->{tracks}++;
		};
		$r->{disc}->{maxtrack} = $t
		    if not exists $r->{disc}->{maxtrack}
			or $t > $r->{disc}->{maxtrack};
	    };
	    $r->{$t}->{track} = $1;
	    $r->{$t}->{type} = lc($3);
	} elsif (/^\s*flags\s+([^\r\n]*\S)\s*$/i) {
	    # XXX ignore
	} else {
	    warn "unrecognized .cue line: $_";
	};
    };
    close $cue_fd;
    die "no tracks found in $cue_fname\n"
	if not exists $r->{disc}->{maxtrack};
    die "max track no != num,ber of tracks\n"
	if $r->{disc}->{maxtrack} != $r->{disc}->{tracks};
    # find tracks without title/performer:
    foreach $t (grep {$_ ne "disc"} keys %$r) {
	die "no index01 defined for track $t\n"
	    if not exists $r->{$t}->{index01};
	if ($r->{$t}->{type} eq "audio"
	and (not exists $r->{$t}->{title}
	    or not exists $r->{$t}->{performer}
	    and not exists $r->{disc}->{performer})) {
	    $r->{disc}->{untitled_tracks}->{$t} = 1;
	};
    };
    return $r;
};

sub sum_digits_base_n($$) {
    my ($x, $base) = @_;
    my $s = 0;
    use integer;
    while ($x > 0) {
	$s = $s + ($x % $base);
	$x = $x / $base;
    };
    return $s;
};

sub get_missing_data_from_cddb_or_ape($$) {
    my ($c, $ape_fname) = @_;
    if (exists $c->{disc}->{untitled_tracks} or 1) {
	# Load CDDB.pm library at runtime:
	eval {
	    require CDDB;
	    import  CDDB;
	};
	die "Perl CDDB module is missing\n"
	    if defined $@ and $@ ne "";
	my $cddb = new CDDB(
	    Host  => 'freedb.freedb.org',
	    Login => 'nobody',
	) or die "Cannot init CDDB - $!\n";
	$cddb->{hostname} = "localhost";
	use integer;
	# XXX: track01 typically starts at 2 sec (150 frames) offset:
	@{$c->{disc}->{track_offsets}} =
	    map {150 + $c->{$_}->{index01}->{offs}}
	    sort {$a <=> $b} grep {$_ ne "disc"} keys %$c;
	$c->{disc}->{offsum} = 0;
	$c->{disc}->{offsum} += sum_digits_base_n($_ / 75, 10)
	    foreach @{$c->{disc}->{track_offsets}};
	no integer;
	# detect total play time of the disc:
	if (not exists $c->{disc}->{discid_time} or 1) {
	    # fork child ffmpeg process:
	    my $ffmpeg_pid = open my $ffmpeg_out, "-|";
	    die "cannot fork: $!" if not defined $ffmpeg_pid;
	    if ($ffmpeg_pid == 0) {
		# child
		open STDERR, ">&STDOUT"
		    or die "Cannot redirect STDERR to STDOUT: $!";
		exec {"ffmpeg"} ("ffmpeg", "-i", $ape_fname)
		    or die "Cannot execute ffmpeg: $!";
	    } else {
		# parent
		while (<$ffmpeg_out>) {
		    #  Duration: 00:46:25.43, start: 0.000000, ...
		    if (/^\s*Duration:\s*(\d\d):(\d\d):(\d\d)
		    \.\d+,/ix) {
			$c->{disc}->{ape_time} =
			    ($1 * 60 + $2) * 60 + $3;
		    }
		};
		close $ffmpeg_out;
	    };
	};
	$c->{disc}->{discid2} = sprintf "%02x%04x%02x",
	    $c->{disc}->{offsum} % 255,
	    $c->{disc}->{ape_time},
	    $c->{disc}->{tracks};
	print "get  $c->{disc}->{discid2}: ".join(" ",
	    @{$c->{disc}->{track_offsets}})
	    ." $c->{disc}->{ape_time}\n";
	my @discs = $cddb->get_discs(
	    $c->{disc}->{discid2},
	    $c->{disc}->{track_offsets},
	    $c->{disc}->{ape_time}
	);
	my ($n, $dinfo, @dinfos) = (0);
	foreach my $disc (@discs) {
	    my ($dbgenre, $dbid, $dbperformertitle) = @$disc;
	    $dinfo = $cddb->get_disc_details($dbgenre, $dbid);
	    if ($dinfo->{"disc length"} =~ /(\d+)/) {
		$dinfo->{dlength} = $1;
	    } else {
		die "invalid disc length - "
		    .$dinfo->{"disc length"}."\n";
	    };
	    if ($dbperformertitle =~ m{^(.*) / (.*)$}) {
		($dinfo->{performer}, $dinfo->{title}) = ($1, $2);
	    } else {
		die "invalid disc performer/title - "
		    .$dbperformertitle."\n"
	    };
	    printf "%3i. %s: %s %s\n", $n + 1, $dbid,
		join(" ", @{$dinfo->{offsets}}), $dinfo->{dlength};
	    print "     $dbgenre, $dinfo->{performer} - "
		."$dinfo->{title}\n";
	    $dinfos[$n++] = $dinfo;
	    #print Data::Dumper->Dump([$dinfo]);
	};
	my $chosen_dinfo_no = 0;
	if (scalar(@dinfos) > 1) {
	    my $oldsel = select(STDOUT); $| = 1; select($oldsel);
	    printf "Select a disc data (1-%i) [1]: ",
		scalar(@dinfos);
	    my $choice = <STDIN>;
	    if (not defined $choice) {
		# EOF / Ctrl-D
		print "\n";
		exit 1;
	    };
	    chomp $choice;
	    if ($choice =~ /^\d+$/ and $choice >= 1
	    and $choice <= scalar(@dinfos)) {
		$chosen_dinfo_no = $choice - 1;
	    } elsif ($choice ne "") {
		die "invalid disc data number - $choice\n";
	    };
	};
	$dinfo = $dinfos[$chosen_dinfo_no];
	printf "Selected %i. %s: %s, %04i - %s - %s\n",
	    $chosen_dinfo_no + 1, $dinfo->{discid}, $dinfo->{dgenre},
	    $dinfo->{dyear}, $dinfo->{performer}, $dinfo->{title};
    };
};

foreach my $f (@ARGV) {
    die "invalid filename - $f\n" if not $f =~ /\A(.*)\.(ape|cue)\z/i;
    my ($ape_fname, $cue_fname) = ("$1.ape", "$1.cue");
    foreach my $fname ($ape_fname, $cue_fname) {
	die "$fname doesn't exist\n" if not -e $fname;
    };
    my $c = parse_cue($cue_fname);
    get_missing_data_from_cddb_or_ape($c, $ape_fname);
};

# vi:set sw=4 noet ts=8 tw=71:
