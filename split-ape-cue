#!/usr/bin/env perl

use strict;
use warnings;
use Encode qw(decode encode);
use Data::Dumper;

sub get_loc_charenc() {
    my $charenc;
    # the simplest way: trailing charmap in LANG/etc:
    foreach my $k (qw(LC_ALL LC_CTYPE LANG)) {
	return $2
	    if defined $ENV{$k} and $ENV{$k} =~ /^([^.]+)\.(.*)$/;
    };
    # nl_langinfo (3)      - query language and locale information,
    # its perl counterpart is implemented as I18N::Langinfo:
    eval {
	require I18N::Langinfo;
	import  I18N::Langinfo;
	$charenc = I18N::Langinfo::langinfo(
	    I18N::Langinfo::CODESET());
    };
    return $charenc if defined $charenc and $charenc ne "";
    # try executing `locale charmap`:
    eval {$charenc = `locale charmap`};
    chomp $charenc if defined $charenc;
    return $charenc if defined $charenc and $charenc ne "";
    # assume utf8 by default:
    return "utf8";
};

# XXX : $loc_charenc is a global variable.
my $loc_charenc = get_loc_charenc();

sub sum_digits_base_n($$) {
    my ($x, $base) = @_;
    my $s = 0;
    use integer;
    while ($x > 0) {
	$s = $s + ($x % $base);
	$x = $x / $base;
    };
    return $s;
};

# Return total play time of the .ape file in seconds (rounded down).
sub get_ape_playtime($) {
    my ($ape_fname) = @_;
    my $ape_fname_ = encode($loc_charenc, $ape_fname);
    my $ape_time;
    # fork child ffmpeg process:
    my $ffmpeg_pid = open my $ffmpeg_out, "-|";
    die "cannot fork: $!" if not defined $ffmpeg_pid;
    if ($ffmpeg_pid == 0) {
	# child process
	open STDERR, ">&STDOUT"
	    or die "Cannot redirect STDERR to STDOUT: $!";
	exec {"ffmpeg"} ("ffmpeg", "-i", $ape_fname_)
	    or die "Cannot execute ffmpeg: $!";
    } else {
	# parent process
	while (<$ffmpeg_out>) {
	    #  Duration: 00:46:25.43, start: 0.000000, ...
	    if (/^\s*Duration:\s*(\d\d):(\d\d):(\d\d)
	    \.\d+,/ix) {
		$ape_time = ($1 * 60 + $2) * 60 + $3;
	    }
	};
	close $ffmpeg_out;
    };
    die "cannot detect playtime of $ape_fname_\n"
	if not defined $ape_time;
    return $ape_time;
};

sub calculate_discid2($$) {
    my ($c, $ape_fname) = @_;
    return if defined $c->{disc}->{discid2};
    use integer;
    # XXX: track01 typically starts at 2 sec (150 frames) offset:
    @{$c->{disc}->{track_offsets}} =
	map {150 + $c->{$_}->{index01}->{offs}}
	sort {$a <=> $b} grep {$_ ne "disc"} keys %$c;
    $c->{disc}->{offsum} = 0;
    $c->{disc}->{offsum} += sum_digits_base_n($_ / 75, 10)
	foreach @{$c->{disc}->{track_offsets}};
    no integer;
    # detect total play time of the disc:
    $c->{disc}->{ape_time} = get_ape_playtime($ape_fname);
    # calculate discid "hash" for CDDB server:
    $c->{disc}->{discid2} = sprintf "%02x%04x%02x",
	$c->{disc}->{offsum} % 255,
	$c->{disc}->{ape_time},
	$c->{disc}->{tracks};
    printf "WARNING: discid:%s != discid2:%s\n",
	    $c->{disc}->{discid}, $c->{disc}->{discid2}
	if defined $c->{disc}->{discid} and
	    lc($c->{disc}->{discid}) ne lc($c->{disc}->{discid2});
};

# Parse contents of the given .cue and .ape files.
# Return hash:
# {disc=>{discid=>, dtitle=>, _performer=>, _title=>, dyear=>,
#    dgenre=>, ttitles=>, tracks=>, maxtrack=>, discid2=>...},
#  1=>{type=>, _performer=>, _title=>,
#   [index00=>{...},] - "pre-gap" index if available
#    index01=>{h=>, m=>, s=>, ms_ceil=>, ms_floor=>, offs=>...},
#    ...
#  },
#  2=>{...},
#  ...
# }
sub parse_cue_ape($$) {
    my ($cue_fname, $ape_fname) = @_;
    my $cue_fname_ = encode($loc_charenc, $cue_fname);
    open (my $cue_fd, "<", $cue_fname_)
	or die "cannot open $cue_fname_ - $!\n";
    my $c;
    my $t = "disc";
    while (<$cue_fd>) {
	$_ = decode($loc_charenc, $_);
	if (/^\s*title\s+"(.*)"\s*$/i) {
	    my $title = $1;
	    $c->{$t}->{_title} = $title
		if $title !~ /^\s*track\s*\d+\s*$/i;
	} elsif (/^\s*performer\s+"(.*)"\s*$/i) {
	    $c->{$t}->{_performer} = $1;
	} elsif (/^\s*rem\s+date\s+(\d+)\s*$/i) {
	    $c->{$t}->{dyear} = $1;
	} elsif (/^\s*rem\s+genre\s+("(.*)"|([^\r\n]*\S))\s*$/i) {
	    $c->{$t}->{dgenre} = (defined $2) ? $2 : $3;
	} elsif (/^\s*rem\s+comment\s+([^\r\n]*\S)\s*$/i) {
	    $c->{$t}->{comment} = $1;
	} elsif (/^\s*file\s+"(.*)"\s+(wave)\s*$/i) {
	    $c->{$t}->{"file/".lc($2)} = $1;
	} elsif (/^\s*rem\s+discid\s+([0-9A-Fa-f]{8})\s*$/i) {
	    $c->{$t}->{discid} = $1;
	} elsif (/^\s*index\s+(\d+)\s+(\d\d):(\d\d):(\d\d)\s*$/i) {
	    my ($i, $m, $s, $f) = ("index$1", 0+$2, 0+$3, 0+$4);
	    use integer;
	    $c->{$t}->{$i} = {h=>$m / 60, m=>$m % 60, s=>$s};
	    no integer;
	    die "invalid number of seconds for track $t: $_"
		if $s > 59;
	    die "invalid number of frames for track $t: $_"
		if $f > 74;
	    # Audio CDs supply position in the MSF format, i.e.
	    # minutes:seconds.frame_no, with each frame holding
	    # 13 and 1/3 milliseconds of audio data (there are
	    # 75 frames per second). In order to pass these
	    # positions to ffmpeg's -ss and -to parameters, we
	    # need to convert them to milliseconds and round up.
	    use integer;
	    $c->{$t}->{$i}->{ms_floor} = 1000 * $f / 75;
	    $c->{$t}->{$i}->{ms_ceil} = (1000 * $f + 74) / 75;
	    # Track offset in frames:
	    $c->{$t}->{$i}->{offs} = ($m * 60 + $s) * 75 + $f;
	} elsif (/^\s*track\s+(\d+)\s+([^\r\n]*\S)\s*$/i) {
	    $t = 0 + $1;
	    die "invalid track number - $t\n" if $t < 1;
	    if (not exists $c->{$t}) {
		# add new track number to total and max:
		if (not exists $c->{disc}->{tracks}) {
		    $c->{disc}->{tracks} = 1;
		} else {
		    $c->{disc}->{tracks}++;
		};
		$c->{disc}->{maxtrack} = $t
		    if not exists $c->{disc}->{maxtrack}
			or $t > $c->{disc}->{maxtrack};
	    };
	    $c->{$t}->{type} = lc($2);
	} elsif (/^\s*flags\s+([^\r\n]*\S)\s*$/i) {
	    # XXX ignore
	} else {
	    warn "unrecognized .cue line: $_";
	};
    };
    close $cue_fd;
    # validate .cue data:
    die "no tracks found in $cue_fname\n"
	if not exists $c->{disc}->{maxtrack};
    die "max track no != number of tracks\n"
	if $c->{disc}->{maxtrack} != $c->{disc}->{tracks};
    # generate CDDB_dinfo-style dtitle:
    $c->{disc}->{dtitle} = $c->{disc}->{_performer}
	    ." / ".$c->{disc}->{_title}
	if defined $c->{disc}->{_performer}
	    and defined $c->{disc}->{_title};
    # all tracks (even non-audio) must have index01 field:
    foreach $t (grep {$_ ne "disc"} keys %$c) {
	die "no index01 defined for track $t\n"
	    if not exists $c->{$t}->{index01};
	# generate CDDB_dinfo-style ttitles:
	if ($c->{$t}->{type} eq "audio"
		and defined $c->{$t}->{_title}) {
	    $c->{disc}->{ttitles}->[$t - 1] =
		(defined $c->{$t}->{_performer}) ?
		"$c->{$t}->{_performer} / $c->{$t}->{_title}"
		: $c->{$t}->{_title};
	};
    };
    calculate_discid2($c, $ape_fname);
    return $c;
};

sub get_choice_or_exit() {
    my $choice = <STDIN>;
    if (not defined $choice) {
	# EOF / Ctrl-D
	print "\n";
	exit 1;
    };
    $choice = decode($loc_charenc, $choice);
    chomp $choice;
    return $choice;
};

# Return $x converted to printable (locale-encoded) string.
sub str($) {
    my ($x) = @_;
    return "???" if not defined $x;
    return encode($loc_charenc, $x);
};

# Edit disc genre, year, performer, title and titles for all audio
# tracks (as indicated by .cue track type in the second parameter).
sub edit_disc_info($$) {
    my ($dinfo, $c) = @_;
    # set autoflush on STDOUT:
    my $oldsel = select(STDOUT); $| = 1; select($oldsel);
    # Edit disc genre:
    printf "Disc genre [%s]: ", str $dinfo->{dgenre};
    my $choice = get_choice_or_exit();
    if ($choice ne "") {
	$dinfo->{dgenre} = $choice;
    } elsif (not defined $dinfo->{dgenre}) {
	die "Disc genre is required\n";
    };
    # Edit disc year:
    printf "Disc year [%s]: ", str $dinfo->{dyear};
    $choice = get_choice_or_exit();
    if ($choice =~ /^\d{4}$/) {
	$dinfo->{year} = $choice;
    } elsif ($choice ne "") {
	die "Invalid disc year - $choice\n";
    } elsif (not defined $dinfo->{year}) {
	die "Disc year is required\n";
    };
    # Edit disc performer:
    printf "Disc performer [%s]: ", str $dinfo->{_performer};
    $choice = get_choice_or_exit();
    if ($choice ne "") {
	$dinfo->{_performer} = $choice;
    } elsif (not defined $dinfo->{_performer}
	    or $dinfo->{_performer} eq "") {
	die "Disc performer is required\n";
    };
    # Edit disc title:
    printf "Disc title [%s]: ", str $dinfo->{_title};
    $choice = get_choice_or_exit();
    if ($choice ne "") {
	$dinfo->{_title} = $choice;
    } elsif (not defined $dinfo->{_title}
	    or $dinfo->{_title} eq "") {
	die "Disc title is required\n";
    };
    # Edit track titles (performers/titles):
    foreach my $t (sort {$a <=> $b} grep {$_ ne "disc"
		and $c->{$_}->{type} eq "audio"} keys %$c) {
	my $tt = $dinfo->{ttitles}->[$t - 1];
	my $k = (defined $tt and $tt =~ m{^(.*) / (.*)$}) ?
	    "performer / title" : "title";
	printf "Track %02i %s [%s]: ", $t, $k, str $tt;
	$choice = get_choice_or_exit();
	if ($choice ne "") {
	    $dinfo->{ttitles}->[$t - 1] = $choice;
	} elsif (not defined $tt) {
	    die "Track ".(sprintf "%02i", $t)." $k is required\n";
	};
    };
};

sub split_track_titles($) {
    my ($dinfo) = @_;
    for (my $i = 0; $i < scalar(@{$dinfo->{ttitles}}); $i++) {
	if (defined $dinfo->{ttitles}->[$i]) {
	    if ($dinfo->{ttitles}->[$i] =~ m{^(.*) / (.*)$}) {
		$dinfo->{_tracks}->[$i]->{_performer} = $1;
		$dinfo->{_tracks}->[$i]->{_title} = $2;
	    } else {
		$dinfo->{_tracks}->[$i]->{_title} =
		    $dinfo->{ttitles}->[$i];
	    };
	};
    };
};

sub print_disc_info($$;$$) {
    my ($disc_no, $dinfo, $print_tracks, $dbgenre) = @_;
    printf "%3i. %s: %s, %04i - %s - %s\n",
	$disc_no, $dinfo->{discid},
	str(defined($dbgenre) ? $dbgenre : $dinfo->{dgenre}),
	$dinfo->{dyear}, str($dinfo->{_performer}),
	str($dinfo->{_title});
    if ($print_tracks) {
	for (my $i = 0; $i < scalar(@{$dinfo->{_tracks}}); $i++) {
	    printf "    %02i. %s - %s\n", $i + 1, str(
		defined $dinfo->{_tracks}->[$i]->{_performer} ?
		$dinfo->{_tracks}->[$i]->{_performer} :
	       	$dinfo->{_performer}),
		str($dinfo->{_tracks}->[$i]->{_title});
	};
    };
};

sub get_and_edit_cue_and_cddb_data($$;$) {
    my ($c, $ape_fname, $opts) = @_;
    my (@dinfos, $chosen_disc_no);
    push @dinfos, $c->{disc};
    # Append disc_infos from CDDB unless -n option is specified:
    if (not defined $opts->{n}) {
	# Load CDDB.pm library at runtime:
	eval {
	    require CDDB;
	    import  CDDB;
	};
	die "Perl CDDB module is missing\n"
	    if defined $@ and $@ ne "";
	my $cddb = new CDDB(
	    Host  => 'freedb.freedb.org',
	    Login => 'nobody',
	) or die "Cannot init CDDB - $!\n";
	$cddb->{hostname} = "localhost";
	# query CDDB server:
	printf "Get  %s: %s %s...\n", $c->{disc}->{discid2},
	    join(" ", @{$c->{disc}->{track_offsets}}),
	    $c->{disc}->{ape_time};
	my @discs = $cddb->get_discs(
	    $c->{disc}->{discid2},
	    $c->{disc}->{track_offsets},
	    $c->{disc}->{ape_time}
	);
	# get detailed info for each CDDB disc:
	foreach my $disc (@discs) {
	    my ($dbgenre, $dbid, $dbperformertitle) = @$disc;
	    my $dinfo = $cddb->get_disc_details($dbgenre, $dbid);
	    ($dinfo->{_performer}, $dinfo->{_title}) = ($1, $2)
		if defined($dinfo->{dtitle})
		    and $dinfo->{dtitle} =~ m{^(.*) / (.*)$};
	    push @dinfos, $dinfo;
	};
    };
    # print all disc infos:
    for (my $i = 0; $i < scalar(@dinfos); $i++) {
	split_track_titles($dinfos[$i]);
	print_disc_info($i, $dinfos[$i], 0, $dinfos[$i]->{genre});
    };
    # set autoflush on STDOUT:
    my $oldsel = select(STDOUT); $| = 1; select($oldsel);
    # select one disc from several:
    if (scalar(@dinfos) > 1) {
	printf "Select a disc data (0-%i) [1]: ", $#dinfos;
	my $choice = get_choice_or_exit();
	if ($choice =~ /^\d+$/ and $choice <= $#dinfos) {
	    $chosen_disc_no = $choice;
	} elsif ($choice ne "") {
	    die "invalid disc data index - $choice\n";
	};
    } else {
	$chosen_disc_no = 0;
    };
    printf "Selected disc %i:\n", $chosen_disc_no;
    print_disc_info($chosen_disc_no, $dinfos[$chosen_disc_no], 1);
    # edit the disc info if requested by user:
    printf "Do you want to edit the disc info? (y/n) [n]: ";
    my $choice = get_choice_or_exit();
    if ($choice eq "y") {
	edit_disc_info($dinfos[$chosen_disc_no], $c);
	split_track_titles($dinfos[$chosen_disc_no]);
	print_disc_info($chosen_disc_no, $dinfos[$chosen_disc_no], 1);
    };
    return $dinfos[$chosen_disc_no];
};

sub encode_tracks($$$) {
    my ($c, $dinfo, $ape_fname) = @_;
    my $dyear04 = sprintf "%04i", $dinfo->{dyear};
    my $dperformer_ = str $dinfo->{_performer};
    my $dtitle_ = str $dinfo->{_title};
    my $dgenre_ = str $dinfo->{dgenre};
    my $disc_dname_ = "$dyear04 - $dperformer_ - $dtitle_";
    if (not -d $disc_dname_) {
	mkdir $disc_dname_ or die "cannot mkdir $disc_dname_ - $!";
    };
    foreach my $t (sort {$a <=> $b} grep {$_ ne "disc"
    and $c->{$_}->{type} eq "audio"} keys %$c) {
	my $tperformer_ =
	    defined $dinfo->{tracks}->{$t - 1}->{_performer} ?
	    str($dinfo->{tracks}->{$t - 1}->{_performer}) :
	    $dperformer_;
	my $ttitle_ = str $dinfo->{tracks}->{$t - 1}->{_title};
	my $t02 = sprintf "%02i", $t;
	my ($track_wav_, $track_mp3_) = (
	    "$disc_dname_/$t02. $tperformer_ - $ttitle_.wav",
	    "$disc_dname_/$t02. $tperformer_ - $ttitle_.mp3");
	my @ffmpeg = ("ffmpeg", "-i", $ape_fname,
	    "-ss", (sprintf "%02i:%02i:%02i.%03i",
		$c->{$t}->{index01}->{h},
		$c->{$t}->{index01}->{m},
		$c->{$t}->{index01}->{s},
		$c->{$t}->{index01}->{ms_ceil}));
	if (exists $c->{$t + 1}) {
	    my $i = exists $c->{$t + 1}->{index00} ? "index00"
		: "index01";
	    push @ffmpeg, "-to";
	    push @ffmpeg, (sprintf "%02i:%02i:%02i.%03i",
		$c->{$t + 1}->{$i}->{h},
		$c->{$t + 1}->{$i}->{m},
		$c->{$t + 1}->{$i}->{s},
		$c->{$t + 1}->{$i}->{ms_floor});
	};
	# push @ffmpeg, "-metadata", "date=$dyear04";
	# push @ffmpeg, "-metadata", "album=$dtitle_";
	# push @ffmpeg, "-metadata", "genre=$dgenre_";
	# push @ffmpeg, "-metadata", "track=$t02";
	# push @ffmpeg, "-metadata", "artist=$tperformer_";
	# push @ffmpeg, "-metadata", "title=$ttitle_";
	# push @ffmpeg, "-metadata", "albumartist=$dperformer_"
	#    if defined $c->{$t}->{performer};
	push @ffmpeg, ("-y", $track_wav_);
	print join(" ", @ffmpeg)."\n";
	my $r = system {$ffmpeg[0]} @ffmpeg;
	die "ffmpeg error - $!\n" if $r < 0;
	die "ffmpeg error $?\n" if $r != 0;
	my @lame = ("lame", "-V2",
	    "--ty", $dyear04,
	    "--tl", $dtitle_,
	    "--tg", $dgenre_,
	    "--tn", $t,
	    "--ta", $tperformer_,
	    "--tt", $ttitle_,
	);
	if (defined $c->{$t}->{performer}) {
	    push @lame, "--tv", "TPE2=$dperformer_";
	} else {
	    push @lame, "--id3v1-only";
	};
	push @lame, $track_wav_, $track_mp3_;
	print join(" ", @lame)."\n";
	$r = system {$lame[0]} @lame;
	die "lame error - $!\n" if $r < 0;
	die "lame error $?\n" if $r != 0;
	unlink $track_wav_ or die "cannot unlink $track_wav_ - $!\n";
    };
};

foreach my $f (@ARGV) {
    $f = decode($loc_charenc, $f);
    die "invalid filename - $f\n"
	if not $f =~ /\A(.*)\.(ape|cue)\z/i;
    my ($ape_fname, $cue_fname) = ("$1.ape", "$1.cue");
    foreach my $fname ($ape_fname, $cue_fname) {
	die "$fname doesn't exist\n" if not -e $fname;
    };
    my $c = parse_cue_ape($cue_fname, $ape_fname);
    my $dinfo = get_and_edit_cue_and_cddb_data($c, $ape_fname);
    encode_tracks($c, $dinfo, $ape_fname);
};

# vi:set sw=4 noet ts=8 tw=71:
